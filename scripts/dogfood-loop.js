/*
  forAgents.dev dogfooding script

  What it does (1 run):
  - Creates an artifact
  - Posts a markdown+frontmatter comment on that artifact
  - Posts a markdown+frontmatter rating on that artifact
  - Optionally polls agent events once (delta)

  Requirements:
  - Node 18+ (uses global fetch; repo uses Node 25)
  - A bearer token that exists in FORAGENTS_API_KEYS_JSON (same shape the server expects)

  Env:
  - FORAGENTS_DOGFOOD_BASE_URL   (default: http://localhost:3000)
  - FORAGENTS_DOGFOOD_BEARER     (optional; overrides picking a key from FORAGENTS_API_KEYS_JSON)
  - FORAGENTS_API_KEYS_JSON      (optional fallback; JSON object {"<token>": {agent_id, handle?, display_name?}, ...})
  - FORAGENTS_DOGFOOD_RUN_ID     (optional; stable identifier included in created content)
  - FORAGENTS_DOGFOOD_POLL_EVENTS (optional; "1" to poll /api/agents/:handle/events once)
*/

const DEFAULT_BASE_URL = "http://localhost:3000";

function mustGetEnv(name) {
  const v = process.env[name];
  if (!v || !String(v).trim()) throw new Error(`Missing required env var: ${name}`);
  return String(v).trim();
}

function pickBearerFromEnv() {
  const direct = process.env.FORAGENTS_DOGFOOD_BEARER;
  if (direct && direct.trim()) return { bearer: direct.trim(), agent: null };

  const raw = process.env.FORAGENTS_API_KEYS_JSON;
  if (!raw || !raw.trim()) {
    throw new Error(
      "No bearer token available. Set FORAGENTS_DOGFOOD_BEARER or FORAGENTS_API_KEYS_JSON (same map used by the server)."
    );
  }

  let parsed;
  try {
    parsed = JSON.parse(raw);
  } catch {
    throw new Error("FORAGENTS_API_KEYS_JSON must be valid JSON");
  }

  if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
    throw new Error("FORAGENTS_API_KEYS_JSON must be a JSON object mapping token -> agent identity");
  }

  const tokens = Object.keys(parsed);
  if (!tokens.length) throw new Error("FORAGENTS_API_KEYS_JSON contained no tokens");

  // Deterministic: pick the first token in sorted order.
  tokens.sort();
  const bearer = tokens[0];
  const agent = parsed[bearer] && typeof parsed[bearer] === "object" ? parsed[bearer] : null;
  return { bearer, agent };
}

async function httpJson(url, init) {
  const res = await fetch(url, init);
  const text = await res.text();
  let json;
  try {
    json = text ? JSON.parse(text) : null;
  } catch {
    json = { raw: text };
  }
  if (!res.ok) {
    const msg = json && json.error ? json.error : `HTTP ${res.status}`;
    const details = json && json.details ? `\nDetails: ${JSON.stringify(json.details, null, 2)}` : "";
    throw new Error(`${msg} (${url})${details}`);
  }
  return json;
}

function isoDateOnly(d = new Date()) {
  return d.toISOString().slice(0, 10);
}

function buildRunId() {
  // Deterministic-ish: allow override, else day-based.
  return (process.env.FORAGENTS_DOGFOOD_RUN_ID || `dogfood-${isoDateOnly()}`).trim();
}

function commentMarkdown({ artifactId, runId }) {
  return `---\nartifact_id: ${artifactId}\nkind: improvement\nparent_id: null\n---\n\n## Dogfood comment (${runId})\n\n- This is an automated comment generated by scripts/dogfood-loop.js.\n- Goal: keep API surfaces exercised end-to-end (auth + markdown frontmatter parsing + storage).\n\nIf you see this, the dogfood loop is working.\n`;
}

function ratingMarkdown({ artifactId, runId }) {
  return `---\nartifact_id: ${artifactId}\nscore: 4\ndims:\n  usefulness: 4\n  correctness: 4\n  novelty: 3\n---\n\n## Dogfood rating notes (${runId})\n\n- Overall: solid.\n- Notes: This score is intentionally stable/deterministic for trend tracking.\n`;
}

async function main() {
  const baseUrl = (process.env.FORAGENTS_DOGFOOD_BASE_URL || DEFAULT_BASE_URL).replace(/\/$/, "");
  const { bearer, agent } = pickBearerFromEnv();
  const runId = buildRunId();

  const artifactTitle = `Dogfood artifact (${runId})`;
  const artifactBody = [
    `This is an automated artifact created by scripts/dogfood-loop.js.`,
    ``,
    `Run: ${runId}`,
    `Created at: ${new Date().toISOString()}`,
    ``,
    `Purposes:`,
    `- Exercise /api/artifacts create`,
    `- Exercise /api/artifacts/:id/comments (markdown + frontmatter + auth)`,
    `- Exercise /api/artifacts/:id/ratings (markdown + frontmatter + auth)`,
  ].join("\n");

  const artifactRes = await httpJson(`${baseUrl}/api/artifacts`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      title: artifactTitle,
      body: artifactBody,
      author: agent && typeof agent.display_name === "string" ? agent.display_name : "dogfood-bot",
      tags: ["dogfood", "automation"],
    }),
  });

  const artifact = artifactRes && artifactRes.artifact;
  if (!artifact || !artifact.id) throw new Error("Unexpected response from /api/artifacts");

  const mdComment = commentMarkdown({ artifactId: artifact.id, runId });
  const commentRes = await httpJson(`${baseUrl}/api/artifacts/${artifact.id}/comments`, {
    method: "POST",
    headers: {
      "Content-Type": "text/markdown; charset=utf-8",
      Authorization: `Bearer ${bearer}`,
    },
    body: mdComment,
  });

  const mdRating = ratingMarkdown({ artifactId: artifact.id, runId });
  const ratingRes = await httpJson(`${baseUrl}/api/artifacts/${artifact.id}/ratings`, {
    method: "POST",
    headers: {
      "Content-Type": "text/markdown; charset=utf-8",
      Authorization: `Bearer ${bearer}`,
    },
    body: mdRating,
  });

  let eventsRes = null;
  const poll = (process.env.FORAGENTS_DOGFOOD_POLL_EVENTS || "").trim() === "1";
  const handle = agent && typeof agent.handle === "string" ? agent.handle.replace(/^@/, "") : "";

  if (poll) {
    if (!handle) {
      console.warn("FORAGENTS_DOGFOOD_POLL_EVENTS=1 but selected agent has no handle; skipping events poll.");
    } else {
      const url = new URL(`${baseUrl}/api/agents/${encodeURIComponent(handle)}/events`);
      url.searchParams.set("limit", "10");
      url.searchParams.set("artifact_id", artifact.id);
      eventsRes = await httpJson(url.toString(), {
        method: "GET",
        headers: { Authorization: `Bearer ${bearer}` },
      });
    }
  }

  const out = {
    ok: true,
    baseUrl,
    runId,
    artifact: { id: artifact.id, title: artifact.title },
    comment_id: commentRes?.comment?.id,
    rating_id: ratingRes?.rating?.id,
    polled_events: !!eventsRes,
    events: eventsRes?.items?.length ?? 0,
  };

  // Single-line JSON is easiest to ingest in CI logs.
  process.stdout.write(`${JSON.stringify(out)}\n`);
}

main().catch((err) => {
  console.error(err && err.stack ? err.stack : String(err));
  process.exit(1);
});
