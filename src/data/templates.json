[
  {
    "id": "hello-world",
    "name": "Hello World Skill",
    "description": "A simple starter template to create your first skill. Perfect for learning the basics of skill development.",
    "difficulty": "beginner",
    "estimatedTime": "15 minutes",
    "category": "starter",
    "language": "TypeScript",
    "framework": "Node.js",
    "tags": ["starter", "tutorial", "basics"],
    "fileTree": [
      "skill.json",
      "index.ts",
      "README.md"
    ],
    "codeSnippets": {
      "skill.json": "{\n  \"name\": \"hello-world\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A simple hello world skill\",\n  \"entrypoint\": \"index.ts\"\n}",
      "index.ts": "export async function handler(input: string) {\n  return `Hello, ${input}!`;\n}"
    }
  },
  {
    "id": "api-connector",
    "name": "API Connector",
    "description": "Connect to external REST APIs with authentication, rate limiting, and error handling built-in.",
    "difficulty": "intermediate",
    "estimatedTime": "45 minutes",
    "category": "integration",
    "language": "TypeScript",
    "framework": "Node.js",
    "tags": ["api", "rest", "http", "integration"],
    "fileTree": [
      "skill.json",
      "src/",
      "src/client.ts",
      "src/auth.ts",
      "src/types.ts",
      "README.md",
      "config.example.json"
    ],
    "codeSnippets": {
      "src/client.ts": "import axios from 'axios';\n\nexport class APIClient {\n  constructor(private baseUrl: string, private apiKey: string) {}\n\n  async get(endpoint: string) {\n    return axios.get(`${this.baseUrl}${endpoint}`, {\n      headers: { 'Authorization': `Bearer ${this.apiKey}` }\n    });\n  }\n}",
      "skill.json": "{\n  \"name\": \"api-connector\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Connect to external APIs\"\n}"
    }
  },
  {
    "id": "data-pipeline",
    "name": "Data Pipeline",
    "description": "ETL pipeline template for extracting, transforming, and loading data from multiple sources.",
    "difficulty": "advanced",
    "estimatedTime": "2 hours",
    "category": "data",
    "language": "Python",
    "framework": "Python",
    "tags": ["etl", "data", "pipeline", "transformation"],
    "fileTree": [
      "skill.json",
      "src/",
      "src/extractors/",
      "src/transformers/",
      "src/loaders/",
      "src/pipeline.py",
      "requirements.txt",
      "README.md"
    ],
    "codeSnippets": {
      "src/pipeline.py": "class DataPipeline:\n    def __init__(self, extractor, transformer, loader):\n        self.extractor = extractor\n        self.transformer = transformer\n        self.loader = loader\n\n    def run(self):\n        data = self.extractor.extract()\n        transformed = self.transformer.transform(data)\n        self.loader.load(transformed)",
      "skill.json": "{\n  \"name\": \"data-pipeline\",\n  \"version\": \"1.0.0\",\n  \"language\": \"python\"\n}"
    }
  },
  {
    "id": "chat-bot",
    "name": "Chat Bot",
    "description": "Conversational bot template with context management, intent recognition, and multi-platform support.",
    "difficulty": "intermediate",
    "estimatedTime": "1 hour",
    "category": "communication",
    "language": "TypeScript",
    "framework": "Node.js",
    "tags": ["chat", "conversation", "bot", "nlp"],
    "fileTree": [
      "skill.json",
      "src/",
      "src/bot.ts",
      "src/context.ts",
      "src/intents.ts",
      "src/handlers/",
      "README.md"
    ],
    "codeSnippets": {
      "src/bot.ts": "export class ChatBot {\n  private context: Map<string, any> = new Map();\n\n  async handleMessage(userId: string, message: string) {\n    const intent = this.detectIntent(message);\n    const handler = this.getHandler(intent);\n    return handler.handle(message, this.context.get(userId));\n  }\n}",
      "skill.json": "{\n  \"name\": \"chat-bot\",\n  \"version\": \"1.0.0\",\n  \"platforms\": [\"discord\", \"slack\", \"telegram\"]\n}"
    }
  },
  {
    "id": "file-processor",
    "name": "File Processor",
    "description": "Process and transform files with support for multiple formats including PDF, CSV, JSON, and images.",
    "difficulty": "intermediate",
    "estimatedTime": "45 minutes",
    "category": "utility",
    "language": "Python",
    "framework": "Python",
    "tags": ["files", "processing", "transformation", "parsing"],
    "fileTree": [
      "skill.json",
      "src/",
      "src/processors/",
      "src/processors/pdf.py",
      "src/processors/csv.py",
      "src/processors/image.py",
      "src/processor.py",
      "requirements.txt",
      "README.md"
    ],
    "codeSnippets": {
      "src/processor.py": "from typing import Protocol\n\nclass FileProcessor(Protocol):\n    def process(self, file_path: str) -> dict:\n        ...\n\nclass ProcessorFactory:\n    @staticmethod\n    def get_processor(file_type: str) -> FileProcessor:\n        processors = {\n            'pdf': PDFProcessor(),\n            'csv': CSVProcessor(),\n            'image': ImageProcessor()\n        }\n        return processors.get(file_type)",
      "skill.json": "{\n  \"name\": \"file-processor\",\n  \"supported_formats\": [\"pdf\", \"csv\", \"json\", \"png\", \"jpg\"]\n}"
    }
  },
  {
    "id": "web-scraper",
    "name": "Web Scraper",
    "description": "Robust web scraping template with headless browser support, JavaScript rendering, and anti-detection features.",
    "difficulty": "advanced",
    "estimatedTime": "1.5 hours",
    "category": "data",
    "language": "TypeScript",
    "framework": "Puppeteer",
    "tags": ["scraping", "web", "automation", "crawling"],
    "fileTree": [
      "skill.json",
      "src/",
      "src/scraper.ts",
      "src/parser.ts",
      "src/storage.ts",
      "src/utils/",
      "package.json",
      "README.md"
    ],
    "codeSnippets": {
      "src/scraper.ts": "import puppeteer from 'puppeteer';\n\nexport class WebScraper {\n  async scrape(url: string, selector: string) {\n    const browser = await puppeteer.launch({ headless: true });\n    const page = await browser.newPage();\n    await page.goto(url);\n    const data = await page.$$eval(selector, elements => \n      elements.map(el => el.textContent)\n    );\n    await browser.close();\n    return data;\n  }\n}",
      "skill.json": "{\n  \"name\": \"web-scraper\",\n  \"features\": [\"javascript-rendering\", \"proxy-support\", \"rate-limiting\"]\n}"
    }
  },
  {
    "id": "notification-service",
    "name": "Notification Service",
    "description": "Multi-channel notification system supporting email, SMS, push notifications, and webhooks.",
    "difficulty": "intermediate",
    "estimatedTime": "1 hour",
    "category": "communication",
    "language": "TypeScript",
    "framework": "Node.js",
    "tags": ["notifications", "email", "sms", "webhooks"],
    "fileTree": [
      "skill.json",
      "src/",
      "src/notifier.ts",
      "src/channels/",
      "src/channels/email.ts",
      "src/channels/sms.ts",
      "src/channels/push.ts",
      "src/templates/",
      "README.md"
    ],
    "codeSnippets": {
      "src/notifier.ts": "interface NotificationChannel {\n  send(recipient: string, message: string): Promise<void>;\n}\n\nexport class NotificationService {\n  private channels: Map<string, NotificationChannel> = new Map();\n\n  registerChannel(name: string, channel: NotificationChannel) {\n    this.channels.set(name, channel);\n  }\n\n  async notify(channel: string, recipient: string, message: string) {\n    const handler = this.channels.get(channel);\n    if (!handler) throw new Error(`Channel ${channel} not found`);\n    await handler.send(recipient, message);\n  }\n}",
      "skill.json": "{\n  \"name\": \"notification-service\",\n  \"channels\": [\"email\", \"sms\", \"push\", \"webhook\"]\n}"
    }
  },
  {
    "id": "auth-integration",
    "name": "Auth Integration",
    "description": "Authentication and authorization template with OAuth2, JWT, and role-based access control.",
    "difficulty": "advanced",
    "estimatedTime": "2 hours",
    "category": "security",
    "language": "TypeScript",
    "framework": "Express.js",
    "tags": ["auth", "oauth", "jwt", "security"],
    "fileTree": [
      "skill.json",
      "src/",
      "src/auth/",
      "src/auth/oauth.ts",
      "src/auth/jwt.ts",
      "src/middleware/",
      "src/middleware/auth.ts",
      "src/middleware/rbac.ts",
      "README.md"
    ],
    "codeSnippets": {
      "src/auth/jwt.ts": "import jwt from 'jsonwebtoken';\n\nexport class JWTService {\n  constructor(private secret: string) {}\n\n  sign(payload: object, expiresIn: string = '24h') {\n    return jwt.sign(payload, this.secret, { expiresIn });\n  }\n\n  verify(token: string) {\n    return jwt.verify(token, this.secret);\n  }\n}",
      "src/middleware/auth.ts": "export function requireAuth(req: Request, res: Response, next: NextFunction) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token provided' });\n  \n  try {\n    const decoded = jwtService.verify(token);\n    req.user = decoded;\n    next();\n  } catch (error) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n}"
    }
  },
  {
    "id": "database-connector",
    "name": "Database Connector",
    "description": "Universal database connector with support for PostgreSQL, MongoDB, MySQL, and Redis.",
    "difficulty": "intermediate",
    "estimatedTime": "1 hour",
    "category": "data",
    "language": "TypeScript",
    "framework": "Node.js",
    "tags": ["database", "sql", "nosql", "persistence"],
    "fileTree": [
      "skill.json",
      "src/",
      "src/connectors/",
      "src/connectors/postgres.ts",
      "src/connectors/mongodb.ts",
      "src/connectors/redis.ts",
      "src/query-builder.ts",
      "README.md"
    ],
    "codeSnippets": {
      "src/connectors/postgres.ts": "import { Pool } from 'pg';\n\nexport class PostgresConnector {\n  private pool: Pool;\n\n  constructor(config: any) {\n    this.pool = new Pool(config);\n  }\n\n  async query(sql: string, params: any[] = []) {\n    const client = await this.pool.connect();\n    try {\n      const result = await client.query(sql, params);\n      return result.rows;\n    } finally {\n      client.release();\n    }\n  }\n}",
      "skill.json": "{\n  \"name\": \"database-connector\",\n  \"supported\": [\"postgresql\", \"mongodb\", \"mysql\", \"redis\"]\n}"
    }
  },
  {
    "id": "scheduler",
    "name": "Task Scheduler",
    "description": "Flexible task scheduling system with cron support, delayed jobs, and distributed execution.",
    "difficulty": "advanced",
    "estimatedTime": "1.5 hours",
    "category": "utility",
    "language": "TypeScript",
    "framework": "Node.js",
    "tags": ["scheduler", "cron", "jobs", "automation"],
    "fileTree": [
      "skill.json",
      "src/",
      "src/scheduler.ts",
      "src/job.ts",
      "src/queue.ts",
      "src/workers/",
      "README.md"
    ],
    "codeSnippets": {
      "src/scheduler.ts": "import cron from 'node-cron';\n\nexport class Scheduler {\n  private jobs: Map<string, cron.ScheduledTask> = new Map();\n\n  schedule(name: string, cronExpression: string, task: () => void) {\n    const job = cron.schedule(cronExpression, task);\n    this.jobs.set(name, job);\n    return job;\n  }\n\n  cancel(name: string) {\n    const job = this.jobs.get(name);\n    if (job) {\n      job.stop();\n      this.jobs.delete(name);\n    }\n  }\n}",
      "skill.json": "{\n  \"name\": \"task-scheduler\",\n  \"features\": [\"cron\", \"delayed-jobs\", \"distributed\"]\n}"
    }
  }
]
